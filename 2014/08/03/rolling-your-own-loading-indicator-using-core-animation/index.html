<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Rolling Your Own Loading Indicator Using Core Animation | A Blog</title>
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta content='width=device-width' name='viewport' />
    <link type="text/css" media="screen" href="/stylesheets/app.css?1433645362" rel="stylesheet" />
  </head>
  <body>
    <div id="header">
      <h1><a href="/">A Blog</a></h1>
    </div>
    
    <div id="main" role="main">
        <h1 class="post">Rolling Your Own Loading Indicator Using Core Animation</h1>
        <p class="article-meta">
          Aug  3, 2014
            / <a href="/tags/ios/">iOS</a>
        </p>
      <p>If you&#39;re bored seeing that default <code>UIActivityIndicator</code> over and over again, it is time to create your own activity indicator. You might think rolling your own activity indicator is a huge hassle. In reality, a loading indicator is made of combination of shapes being animated. This can be done in your iOS code without animated gif or fancy video!</p>

<p>Generally, you will need to have some mockups in mind, decompose the shapes and animation, then create the implementation. As an example, we&#39;ll dabble with <code>Core Animation</code> (pure iOS codes!) to make our loading indicator.</p>

<h2>Setting Up the Loading Indicator Class</h2>

<p><strong>How do we decide necessary the abilities of our loading indicator?</strong> Let&#39;s mimic <code>UIActivityIndicator</code> class definition to provide the properties and methods needed for our loading indicator.</p>
<div class="highlight objective_c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">@interface</span> <span class="nc">MyLoadingIndicatorView</span> <span class="p">:</span> <span class="nc">UIView</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">isAnimating</span><span class="p">)</span> <span class="n">BOOL</span> <span class="n">animating</span><span class="p">;</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">startAnimating</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stopAnimating</span><span class="p">;</span>
<span class="k">@end</span>
</pre></td></tr></tbody></table>
</div>

<p>The <code>startAnimating</code> method initiates infinite animation of the indicator. The <code>stopAnimating</code> method terminates the infinite animation, preferably using some animation too. The <code>animating</code> property explains the indicator state whether it is indeed animating.</p>

<h2><s>Creating</s> Copying a Loading Indicator (from QuizUp)</h2>

<div style="text-align: center; margin-top: 1em;">
  <a href="http://cl.ly/2u1O241x2t2c/QULoadingIndicatorView.mov" target="_blank" alt="A Replica of QuizUp Loading Indicator">
    <img src="/images/2014-08-03-rolling-your-own-loading-indicator-using-core-animation/QULoadingIndicatorView.gif" alt="A Replica of QuizUp Loading Indicator" class="no-border" />
  </a>
  <p style="font-style: italic; font-size: 0.9em;">A Replica of QuizUp Loading Indicator</p>
</div>

<p>When I saw <a href="https://www.quizup.com/en">QuizUp</a> for the first time, I found its loading indicator really interesting! The indicator consists of two main <strong>shapes</strong>: <em>circles</em> and <em>triangles</em>. By observing, we can find that...</p>

<ol>
<li>The <em>circles</em> scale in turns, changing colors based on an array of colors, cycling back when reaching the end of array.</li>
<li>The thunder consists of two <em>triangles</em>.</li>
</ol>

<p>Is everything doable in code? Yes! We can draw the shapes above using <code>CALayer</code>, and perform the animation using <code>CAAnimation</code>. Here are overall steps.</p>

<h3>1. Creating a Container View for Both Shapes</h3>

<p><img title="The Container View" alt="The Container View" src="/images/2014-08-03-rolling-your-own-loading-indicator-using-core-animation/1-the-container-view.png?1433645361" /></p>

<p>Constraints for the container view:</p>

<ul>
<li>Top: 120</li>
<li>Width: 100</li>
<li>Height: 100</li>
<li>Horizontal Center in Container: 0 (Centered Horizontally)</li>
</ul>

<p><img title="The Container View Constraints" alt="The Container View Constraints" src="/images/2014-08-03-rolling-your-own-loading-indicator-using-core-animation/1-the-container-view-constraints.png?1433645361" /></p>

<p>Let&#39;s call this container view <code>QULoadingIndicatorView</code>. We need it because of the following reasons.</p>

<ul>
<li>For sake of sanity, the animating circles should be grouped together and separated from the thunder.</li>
<li>The thunder shape can have different <code>CGRect</code> size from the circles.</li>
</ul>
<div class="highlight objective_c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="c1">// QULoadingIndicatorView.h
</span><span class="k">@interface</span> <span class="nc">QULoadingIndicatorView</span> <span class="p">:</span> <span class="nc">UIView</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">colors</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">getter</span> <span class="o">=</span> <span class="n">isAnimating</span><span class="p">)</span> <span class="n">BOOL</span> <span class="n">animating</span><span class="p">;</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">startAnimating</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stopAnimating</span><span class="p">;</span>
<span class="k">@end</span>
</pre></td></tr></tbody></table>
</div>

<p>In the loading indicator implementation file, we will put empty methods for now. These empty methods will forward to our shapes later, once they are ready.</p>
<div class="highlight objective_c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></td><td class="code"><pre><span class="cp">#import "QUThunderView.h"
</span>
<span class="k">@interface</span> <span class="nc">QULoadingIndicatorView</span> <span class="p">()</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">QULoadingIndicatorView</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">awakeFromNib</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">awakeFromNib</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setColors</span><span class="o">:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="n">colors</span> <span class="p">{</span>
    <span class="c1">// Sets colors of animating circles
</span><span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="n">colors</span> <span class="p">{</span>
    <span class="c1">// Returns colors of animating circles
</span>    <span class="k">return</span> <span class="err">@</span><span class="p">[];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="n">isAnimating</span> <span class="p">{</span>
    <span class="c1">// Returns animation status of the animating circles
</span>    <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">startAnimating</span> <span class="p">{</span>
    <span class="c1">// Start animating circles and set thunder to be visible
</span><span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stopAnimating</span> <span class="p">{</span>
    <span class="c1">// Stop animating circles and set thunder to be invisible
</span><span class="p">}</span>

<span class="k">@end</span>
</pre></td></tr></tbody></table>
</div>

<h3>2. Animating Circles</h3>

<p>Let&#39;s prepare a view for the animating circles, <code>QUAlternatingCirclesView</code>.</p>

<p><img title="The Alternating Circles View" alt="The Alternating Circles View" src="/images/2014-08-03-rolling-your-own-loading-indicator-using-core-animation/2-the-circles.png?1433645361" /></p>

<p>Constraints for the alternating circles view (to fill the container):</p>

<ul>
<li>Top: 0</li>
<li>Left: 0</li>
<li>Right: 0</li>
<li>Bottom: 0</li>
</ul>

<p><img title="The Alternating Circles View Constraints" alt="The Alternating Circles View Constraints" src="/images/2014-08-03-rolling-your-own-loading-indicator-using-core-animation/2-the-circles-constraints.png?1433645361" /></p>
<div class="highlight objective_c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">@interface</span> <span class="nc">QUAlternatingCirclesView</span> <span class="p">:</span> <span class="nc">UIView</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">colors</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">getter</span> <span class="o">=</span> <span class="n">isAnimating</span><span class="p">)</span> <span class="n">BOOL</span> <span class="n">animating</span><span class="p">;</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">startAnimating</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stopAnimating</span><span class="p">;</span>
<span class="k">@end</span>
</pre></td></tr></tbody></table>
</div>

<div style="text-align: center; margin-top: 1em;">
  <a href="http://cl.ly/2u1O241x2t2c/QULoadingIndicatorView.mov" target="_blank" alt="A Replica of QuizUp Loading Indicator">
    <img src="/images/2014-08-03-rolling-your-own-loading-indicator-using-core-animation/QULoadingIndicatorView.gif" alt="A Replica of QuizUp Loading Indicator" class="no-border" />
  </a>
  <p style="font-style: italic; font-size: 0.9em;">A Replica of QuizUp Loading Indicator</p>
</div>

<p>Let&#39;s observe the animation again. When <code>startAnimating</code> is invoked, the circles are scaled alternately from 0 to its container size, 100x100. This means we do scale transform from 0 to identity on each of the circles.</p>
<div class="highlight objective_c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre><span class="c1">// Circle shape
</span><span class="n">CALayer</span> <span class="o">*</span><span class="n">layer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">colorLayers</span><span class="p">[</span><span class="nf">colorLayerIndex</span><span class="p">];</span>
<span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="p">[</span><span class="nf">colorIndex</span><span class="p">]</span> <span class="nf">CGColor</span><span class="p">];</span>
<span class="n">layer</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
<span class="n">layer</span><span class="p">.</span><span class="n">masksToBounds</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
<span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">layer</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="n">layer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DMakeScale</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">layer</span> <span class="nf">addSublayer</span><span class="p">:</span><span class="n">layer</span><span class="p">];</span>

<span class="c1">// Scale animation
</span><span class="n">NSTimeInterval</span> <span class="n">duration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="p">;</span>
<span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">anim</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nf">animationWithKeyPath</span><span class="p">:</span><span class="s">@"transform"</span><span class="p">];</span>
<span class="n">anim</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nf">functionWithName</span><span class="p">:</span><span class="n">kCAMediaTimingFunctionEaseOut</span><span class="p">];</span>
<span class="n">anim</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nf">valueWithCATransform3D</span><span class="p">:</span><span class="n">CATransform3DMakeScale</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
<span class="n">anim</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nf">valueWithCATransform3D</span><span class="p">:</span><span class="n">CATransform3DIdentity</span><span class="p">];</span>
<span class="n">anim</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span><span class="p">;</span>
<span class="n">anim</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
<span class="n">anim</span><span class="p">.</span><span class="n">fillMode</span> <span class="o">=</span> <span class="n">kCAFillModeForwards</span><span class="p">;</span>
<span class="n">anim</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
<span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">animatingColorLayer</span> <span class="nf">addAnimation</span><span class="p">:</span><span class="n">anim</span> <span class="nf">forKey</span><span class="p">:</span><span class="n">anim</span><span class="p">.</span><span class="n">keyPath</span><span class="p">];</span>
</pre></td></tr></tbody></table>
</div>

<p>The nagging question that popped to my head was how many <code>CALayer</code> is needed to make smooth alternating circles. We don&#39;t need layers as many as the colors. Imagine if we want to have 100 colors; having 100 layers is a little bit overkill.</p>

<p>Now let&#39;s change the question. How many is the least number of layers we need? We know at least there should be at least 2 (it can be 3 or more though), because we see that one acts as the background, and another one is animating.</p>

<h4>Experiment 1: Two Instances of CALayer (Back and Animating Layers)</h4>

<p>After the first layer is scaled from 0 to its original size, the second layer should immediately scale from 0 to its original size. After the second layer is scaled, the first one is swapped immediately to be on top of the second one. Unfortunately, during this swapping process, the loading indicator looks <strong>blinking</strong>. This gives the impression that the animation is not smooth...</p>

<h4>Experiment 2: Three Instances of CALayer (Back, Animating, and Front Layers)</h4>

<p>This approach is a superset of the first experiment. In addition to the two layers, we have a third layer behind the second layer.</p>

<p>We will still have the same mechanism as experiment 1. The difference is, after the first layer is send to back of all layers:</p>

<ul>
<li>the second layer acts as the first layer</li>
<li>the third layer acts as the second layer</li>
<li>the first layer acts as the third layer</li>
</ul>

<p>In other words, regardless of the layers&#39; sequence, we always have animating, front, and back color layers.</p>
<div class="highlight objective_c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></td><td class="code"><pre><span class="k">@interface</span> <span class="nc">QUAlternatingCirclesView</span> <span class="p">()</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">getter</span> <span class="o">=</span> <span class="n">isAnimating</span><span class="p">)</span> <span class="n">BOOL</span> <span class="n">animating</span><span class="p">;</span>

<span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSArray</span> <span class="o">*</span><span class="n">colorLayers</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSInteger</span> <span class="n">animatingColorLayerIndex</span><span class="p">;</span>

<span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">CALayer</span> <span class="o">*</span><span class="n">backColorLayer</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">CALayer</span> <span class="o">*</span><span class="n">animatingColorLayer</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">CALayer</span> <span class="o">*</span><span class="n">frontColorLayer</span><span class="p">;</span>

<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSInteger</span> <span class="n">nextColorIndex</span><span class="p">;</span>


<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">QUAlternatingCirclesView</span>

<span class="k">-</span> <span class="p">(</span><span class="n">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="n">backColorLayer</span>
<span class="p">{</span>
    <span class="n">NSInteger</span> <span class="n">backLayerIndex</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">animatingColorLayerIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">backLayerIndex</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">backLayerIndex</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">colorLayers</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">colorLayers</span><span class="p">[</span><span class="nf">backLayerIndex</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="n">animatingColorLayer</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">colorLayers</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="nf">animatingColorLayerIndex</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="n">frontColorLayer</span>
<span class="p">{</span>
    <span class="n">NSInteger</span> <span class="n">frontLayerIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">animatingColorLayerIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">colorLayers</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">colorLayers</span><span class="p">[</span><span class="nf">frontLayerIndex</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// ...
</span>
<span class="k">@end</span>
</pre></td></tr></tbody></table>
</div>

<p>We also have to make sure that the colors assigned to those layers are in sequence of colors given by <code>QULoadingIndicatorView</code>.</p>
<div class="highlight objective_c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92</pre></td><td class="code"><pre><span class="c1">// QUAlternatingCirclesView.m
</span>
<span class="k">@implementation</span> <span class="nc">QUAlternatingCirclesView</span>

<span class="c1">// ...
</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">startAnimating</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">prepareLayers</span><span class="p">];</span>

    <span class="n">self</span><span class="p">.</span><span class="n">animating</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">animateFirst</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// ...
</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">prepareLayers</span>
<span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">colorLayers</span> <span class="o">=</span> <span class="err">@</span><span class="p">[[</span><span class="n">CALayer</span> <span class="nf">layer</span><span class="p">],</span> <span class="p">[</span><span class="n">CALayer</span> <span class="nf">layer</span><span class="p">],</span> <span class="p">[</span><span class="n">CALayer</span> <span class="nf">layer</span><span class="p">]];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">clipsToBounds</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>

    <span class="n">NSArray</span> <span class="o">*</span><span class="n">colors</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">colors</span><span class="p">;</span>
    <span class="n">NSInteger</span> <span class="n">colorsCount</span> <span class="o">=</span> <span class="n">colors</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
    <span class="n">NSInteger</span> <span class="n">colorIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">NSInteger</span> <span class="n">colorLayerIndex</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">colorLayers</span><span class="p">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">colorLayerIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">colorLayerIndex</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">CALayer</span> <span class="o">*</span><span class="n">layer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">colorLayers</span><span class="p">[</span><span class="nf">colorLayerIndex</span><span class="p">];</span>
        <span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="p">[</span><span class="n">colorIndex</span> <span class="o">%</span> <span class="nf">colorsCount</span><span class="p">]</span> <span class="nf">CGColor</span><span class="p">];</span>
        <span class="n">layer</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
        <span class="n">layer</span><span class="p">.</span><span class="n">masksToBounds</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
        <span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">layer</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="n">layer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DMakeScale</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">layer</span> <span class="nf">addSublayer</span><span class="p">:</span><span class="n">layer</span><span class="p">];</span>
        <span class="o">++</span><span class="n">colorIndex</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">animateFirst</span>
<span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">animatingColorLayerIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">nextColorIndex</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="p">[</span><span class="n">self</span> <span class="nf">animateColor</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">animateNext</span>
<span class="p">{</span>
    <span class="n">CALayer</span> <span class="o">*</span><span class="n">backColorLayer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">backColorLayer</span><span class="p">;</span>
    <span class="n">backColorLayer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DMakeScale</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">layer</span> <span class="nf">addSublayer</span><span class="p">:</span><span class="n">backColorLayer</span><span class="p">];</span>

    <span class="n">CALayer</span> <span class="o">*</span><span class="n">frontColorLayer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">frontColorLayer</span><span class="p">;</span>
    <span class="n">frontColorLayer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DMakeScale</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">frontColorLayer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">colors</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">nextColorIndex</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="nf">count</span><span class="p">]</span> <span class="nf">CGColor</span><span class="p">];</span>

    <span class="n">self</span><span class="p">.</span><span class="n">animatingColorLayerIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">animatingColorLayerIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">animatingColorLayerIndex</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">self</span><span class="p">.</span><span class="n">animatingColorLayerIndex</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">colorLayers</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">nextColorIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">nextColorIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>

    <span class="p">[</span><span class="n">self</span> <span class="nf">animateColor</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">animateColor</span>
<span class="p">{</span>
    <span class="n">NSTimeInterval</span> <span class="n">duration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">anim</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nf">animationWithKeyPath</span><span class="p">:</span><span class="s">@"transform"</span><span class="p">];</span>
    <span class="n">anim</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nf">functionWithName</span><span class="p">:</span><span class="n">kCAMediaTimingFunctionEaseOut</span><span class="p">];</span>
    <span class="n">anim</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nf">valueWithCATransform3D</span><span class="p">:</span><span class="n">CATransform3DMakeScale</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
    <span class="n">anim</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nf">valueWithCATransform3D</span><span class="p">:</span><span class="n">CATransform3DIdentity</span><span class="p">];</span>
    <span class="n">anim</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span><span class="p">;</span>
    <span class="n">anim</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="n">anim</span><span class="p">.</span><span class="n">fillMode</span> <span class="o">=</span> <span class="n">kCAFillModeForwards</span><span class="p">;</span>
    <span class="n">anim</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">animatingColorLayer</span> <span class="nf">addAnimation</span><span class="p">:</span><span class="n">anim</span> <span class="nf">forKey</span><span class="p">:</span><span class="n">anim</span><span class="p">.</span><span class="n">keyPath</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#pragma mark - CAAnimationDelegate
</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">animationDidStop</span><span class="o">:</span><span class="p">(</span><span class="n">CAAnimation</span> <span class="o">*</span><span class="p">)</span><span class="n">anim</span> <span class="n">finished</span><span class="o">:</span><span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="n">finished</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">isAnimating</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">animateNext</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">CALayer</span> <span class="o">*</span><span class="n">colorLayer</span> <span class="k">in</span> <span class="n">self</span><span class="p">.</span><span class="n">colorLayers</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[</span><span class="n">colorLayer</span> <span class="nf">removeFromSuperlayer</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">@end</span>

</pre></td></tr></tbody></table>
</div>

<p>The result of experiment 2 is smoother alternating circles than that of experiment 1.</p>

<div style="text-align: center; margin-top: 1em;">
  <a href="http://cl.ly/2u1O241x2t2c/QULoadingIndicatorView.mov" target="_blank" alt="A Replica of QuizUp Loading Indicator">
    <img src="/images/2014-08-03-rolling-your-own-loading-indicator-using-core-animation/QULoadingIndicatorView.gif" alt="A Replica of QuizUp Loading Indicator" class="no-border" />
  </a>
  <p style="font-style: italic; font-size: 0.9em;">A Replica of QuizUp Loading Indicator</p>
</div>

<h3>3. Making the Thunder Using Triangles</h3>

<p>Prepare <code>QUThunderLayer</code> for displaying the thunder.</p>

<p><img title="The Thunder View" alt="The Thunder View" src="/images/2014-08-03-rolling-your-own-loading-indicator-using-core-animation/3-the-thunder.png?1433645361" /></p>

<p>Constraints for the alternating thunder view (to make it look okay on top of the circles):</p>

<ul>
<li>Top: 20</li>
<li>Left: 30</li>
<li>Right: 30</li>
<li>Bottom: 20</li>
</ul>

<p><img title="The Thunder View Constraints" alt="The Thunder View Constraints" src="/images/2014-08-03-rolling-your-own-loading-indicator-using-core-animation/3-the-thunder-constraints.png?1433645361" /></p>

<p>The thunder consist of one triangle on the left and another one on the right. We can use two <code>UIBezierPath</code> to create the two triangles.</p>
<div class="highlight objective_c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></td><td class="code"><pre><span class="c1">// QUThunderView.m
</span>
<span class="c1">// ...
</span>
<span class="k">@implementation</span> <span class="nc">QUThunderLayer</span>

<span class="c1">// ...
</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setupLeftTriangle</span> <span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">leftTriangleLayer</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAShapeLayer</span> <span class="nf">layer</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">leftTriangleLayer</span><span class="p">.</span><span class="n">fillColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nf">whiteColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
    <span class="n">UIBezierPath</span> <span class="o">*</span><span class="n">triangle</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nf">bezierPath</span><span class="p">];</span>

    <span class="n">CGFloat</span> <span class="n">minX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">minY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">CGFloat</span> <span class="n">maxX</span> <span class="o">=</span> <span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">);</span>
    <span class="n">CGFloat</span> <span class="n">maxY</span> <span class="o">=</span> <span class="n">CGRectGetMaxY</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">)</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">66</span><span class="p">;</span>
    <span class="p">[</span><span class="n">triangle</span> <span class="nf">moveToPoint</span><span class="p">:(</span><span class="n">CGPoint</span><span class="p">){</span><span class="n">maxX</span><span class="p">,</span> <span class="n">minY</span><span class="p">}];</span>
    <span class="p">[</span><span class="n">triangle</span> <span class="nf">addLineToPoint</span><span class="p">:(</span><span class="n">CGPoint</span><span class="p">){</span><span class="n">maxX</span><span class="p">,</span> <span class="n">maxY</span><span class="p">}];</span>
    <span class="p">[</span><span class="n">triangle</span> <span class="nf">addLineToPoint</span><span class="p">:(</span><span class="n">CGPoint</span><span class="p">){</span><span class="n">minX</span><span class="p">,</span> <span class="n">maxY</span><span class="p">}];</span>
    <span class="p">[</span><span class="n">triangle</span> <span class="nf">closePath</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">leftTriangleLayer</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">.</span><span class="n">CGPath</span><span class="p">;</span>

    <span class="p">[</span><span class="n">self</span> <span class="nf">addSublayer</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">leftTriangleLayer</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setupRightTriangle</span> <span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">rightTriangleLayer</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAShapeLayer</span> <span class="nf">layer</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">rightTriangleLayer</span><span class="p">.</span><span class="n">fillColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nf">whiteColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>

    <span class="n">UIBezierPath</span> <span class="o">*</span><span class="n">triangle</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nf">bezierPath</span><span class="p">];</span>

    <span class="n">CGFloat</span> <span class="n">minX</span> <span class="o">=</span> <span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">),</span> <span class="n">minY</span> <span class="o">=</span> <span class="n">CGRectGetMaxY</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">)</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">33</span><span class="p">;</span>
    <span class="n">CGFloat</span> <span class="n">maxX</span> <span class="o">=</span> <span class="n">CGRectGetMaxX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">);</span>
    <span class="n">CGFloat</span> <span class="n">maxY</span> <span class="o">=</span> <span class="n">CGRectGetMaxY</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">);</span>
    <span class="p">[</span><span class="n">triangle</span> <span class="nf">moveToPoint</span><span class="p">:(</span><span class="n">CGPoint</span><span class="p">){</span><span class="n">minX</span><span class="p">,</span> <span class="n">minY</span><span class="p">}];</span>
    <span class="p">[</span><span class="n">triangle</span> <span class="nf">addLineToPoint</span><span class="p">:(</span><span class="n">CGPoint</span><span class="p">){</span><span class="n">maxX</span><span class="p">,</span> <span class="n">minY</span><span class="p">}];</span>
    <span class="p">[</span><span class="n">triangle</span> <span class="nf">addLineToPoint</span><span class="p">:(</span><span class="n">CGPoint</span><span class="p">){</span><span class="n">minX</span><span class="p">,</span> <span class="n">maxY</span><span class="p">}];</span>
    <span class="p">[</span><span class="n">triangle</span> <span class="nf">closePath</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">rightTriangleLayer</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">.</span><span class="n">CGPath</span><span class="p">;</span>

    <span class="p">[</span><span class="n">self</span> <span class="nf">addSublayer</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">rightTriangleLayer</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>


<span class="k">@implementation</span> <span class="nc">QUThunderView</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">awakeFromNib</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="nf">awakeFromNib</span><span class="p">];</span>
    <span class="c1">// Add an instance of QUThunderLayer to this view's layer
</span><span class="p">}</span>

<span class="k">@end</span>
</pre></td></tr></tbody></table>
</div>

<h2>Full Source Code</h2>

<p>The rest of the details (like implementation details of <code>stopAnimating</code> and <code>QULoadingIndicatorView</code>) are available as full source code in <a href="http://git.io/CyQvSw">this GitHub repository</a>. Feel free to run the project to play around with the loading indicator. If you want to use it, copy <code>QULoadingIndicatorView.*</code>, <code>QUThunderView.*</code>, and <code>QUAlternatingCirclesView.*</code> to your project.</p>

<br/><br/>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'tree-d';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<hr/>
    </div>

    <div id="footer">
      <p><a href="/">A Blog</a></p>
    </div>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-38935144-1']);
      _gaq.push(['_trackPageview']);
      _gaq.push(['_trackPageLoadTime']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </body>
</html>
